/*

Общие задачи:

1. Песочница.
2. Оформленная стартовая страница.
3. Википедия.

Песочница:
1. Сохранение и чтение миров.
1.1. Анимация ожидания базы.
1.2. Сериализация, сохранение и чтение мира.


Сериализация:
Мир есть в массивах. Нужно упаковать его в бинарный массив или строку и отправить на сервер в теле запроса.
Первая проблема - сериализация.
Как лучше сериализовать объекты в js?

Вариант 1: делаем json.
Координаты клеток придется паковать в виде чисел с именами - слишком много данных.
Экономнее - записать в строку в виде чисел или сериализовать бинарные данные непосредственно.
Можно перобразовать в массив строк. Тогда имена не понадобятся. 

Модель для сохранения: получаем список моделей с именами и слотами при сохранении.
Модель для чтения - аналогично.
При сохранении мира отправляем на сервер мир уже с данными - это пара - модель для сохранения + данные мира.
Данные мира - это просто массив.
Для мира потребуется так же позиция и масштаб. Для этого к данными мира можно приложить еще данные view.


2. Добавить авторизацию пользователей. 
3. Сохранение миров с учетом авторизации.
4. Полноценное масштабирование миров. 

Стартовая страница:
Добавить какое-то описание, сделать фон в виде развивающегося автомата.

Википедия:
1. Возможность просмотра и добавления статей с созданными мирами.
Мир редактируется так же как в песочнице.
2. Можно лайкать статьи. Можно утверждать их или удалять, если ты администратор.

Создание задач:
1. Рисуем задачу поле для ее выполения.
Если задача признана удачной, она попадает в миссии.

Миссии:
Упорядоченные неким образом задачи, решая которые можно прокачиваться.

Перспективы:
Полноценный гейм-плей с персонажем, учетом энергии и цикличности.
Можно обойтись без платформ и переносить точки внутри персонажа.
Освоение космоса - запуск большого количества материи и торможении ее на новой платформе, где можно снова заняться захватом точек.
Через космос можно идти только пустым. 




Авторизация:
1. При попытке сохранения или чтения идет перенаправление на страницу авторизации.
Значит нужно добавить путь, который будет рендерить эту страницу на главной странице.
Дальше, нужно разработать эту страницу.
На странице авторизации есть ссылка на регистрацию.
На странице регистрации предлагается ввести почтовый ящик и пароль два раза.
Затем сервер высылает письмо и показывается снова страница авторизации.
Сервер запоминает не активированного пользователя. Пользователь активируется если письмо подтверждено или удаляется через некоторое время.
Когда пользователь кликает письмо, пользователь активируется передаваемым кодом. Дальше можно логиниться.
Это все можно сделать добавив авторизацию только в EF, потому что регистрация идет без авторизации.

2. На сервере нужно включить какой-то вариант авторизации. Форма авторизации выводится каждый раз при необходимости.
Компонент авторизации можно показывать на отдельной странице.


Вариант - обойтись без редиректа.
Тога дужен компонент с диалогом.
Этот диалог можно встраивать в код страницы с которой нужна авторизация.
Другой вариант - использовать библиотеки ангулара для встраивания диалогов.

На странице можно выделить место для диалогов. Диалоги будут срендерены в это мето.
Дальше, это место можно сделать видимым в зависимости от того какой диалог нужно показать.

Можно ли вставить диалог в страницу динамически? 
Диалог работает со своими данными. После того как он отработал нужно получить данные из него.
И того, нужно:
1. Динамически вставить компонент диалога в страницу (или активировать и показать).
2. Получить из диалога сообщение что он закрывается.

Вопросы:
1. Как организовать диалог так, чтобы он открылся.
2. Как динамически встроить нужный диалог (или нужны все?)


Еще раз по общему построению сайта:
1. Нужна входная страница, где можно авторизоваться и получить описание.
На ней работает автомат и выводится текст в котором описано что это за автомат.
2. Переходим в песочницу. Здесь простые кнопки.
3. Переходим в википедию - здесь страницы.
4. Переходим в игру - здесь находится игровое меню, из которого можно создать новый мир и так далее. В этот пункт можно переходить только с регистрацией.

В чем будет заключаться игра в минимальном варианте?
Можно ввести мелкие миры, в которых нужно выжить и достичь определенных результатов.
Другой вариант - бесконечный открытый мир для завоевания и обустройства.
Обосновываемся в одном мире, собираем достаточно ресурсов, устраняем все опасности.
Дальше, собираем ресурсы для путешествия через космос. В космос нужно выгнать много планеров, по прилету их надо остановить.
Это будет начальный набор ресурсов. Дальше нужно начинать освоение.
Цели:
1. Вскрывать существующие хранилища ресурсов.
2. Можно организовать растительный сбор ресурсов.
3. Нужно конкурировать с другими активными формами, которые могут все разрушить.

Возможности растут по причинам:
1. Лучшего понимания как работать с автоматом.
2. Возможно получения ботов.
3. Запаса ресурсов, к которому можно вертуться после гибели.
4. Размера доступной области для оперирования.
5. Возможности оперировать большим числом ресурсов при наличии больших запасов (больше ботов, больше буфер клеток, больше буфер энергии).
6. Возможности выставлять больше клеток за один ход автомата.


Как это сбалансировать?

Простые планеты - с примитивной жизнью, где есть почти открытые ресурсы. Достаточно вскрывать и собирать. 
Опасные - где есть боты, активно атакующие большим числом клеток.

И того, получаем стратегию:
1. Нужно грести клетки, преодолевая защиту из клеток атакуя ее своими подвижными клетками.
2. Получив клетки можно апгрейдить зону доступа, буфер, скорость.
3. Нужно отбивать атаки активных противников и защитать хранилища от них.

Пошаговый или в реальном времени?

Есть минимальная скорость выполнения, медленнее которой ставить нельзя.
Ускорять можно.
Дальше, на момент атаки можно приостанавливать чтобы подумать и сделать несколько шагов.
Приостановки могут быть ограничены если это разные игроки.

Мри мультиплее можно грабить укрепления в отсутствии хозяина.
Пока на планете есть кто-то, войти на нее нельзя.

Непонятно как сбаллансировать захваты в космосе.

Кто-то строит эффективные укрепления для ресурсов.
Создаются накопления.
Накопления нужно защищать от животных, но это может быть не сложно из за однообразного поведения.
Дальше, кто-то может грабить укрепления.




Защита может быть в нескольких вариантах:
1. Стенки, которые невозможно преодолеть без достаточных ресурсов.
2. Укрепления, которые преодолевать дороже, чем внутри хранится ресурсов.
3. Активные укрепления, которые убивают игрока.

Захватив клетки игрок может преобразовать их в свои собственные укрепления.



Дальше, нужно предоставить другим игрокам возможность попробовать взломать эту защиту.
Дальше игрок может построить свои укрепления на этой планете.

Путешествуя можно находить укрепленные кем-то планеты преобразовывать их.
По своим укрепленным планетам можно видеть как их ломали и видеть результаты.
Отбор должен идти в направлении к самым эффективно защищенным планетам.


Для программирования можно начать с википедии и самому ее заполнить.

Какой UI нам нужен?

1. Нужно иметь возможность смотреть статьи.
Каждая статья - это текст и мир. Мир можно запускать с начала, мотать вперед и назад с любой скоростью.
Редактировать нельзя.
Дальше, есть поясняющий текст.
В тексте описывается где смотреть явление, как оно выглядит.
Текст в основном краткий.
Иногда это может быть целая теория, тогда текст длинный. 
В тексте можно ссылаться на конфигурации, тогда они показываются на экране.

Меню с выбором всегда с права на экране.
В меню будет страница содержания, случайная статья, новые статьи, не модерированные статьи, мои статьи.
Пояснение как работать.

На основной панели показывается статья с права и дальше - картинка.

Редактирование:
1. Можно создать статью. Тогда текст становится редактируемым, поле тоже.
В тексте разрешаются простые теги, в результате формируется html.
После сохранения сохраняется новая статья, которая актуализируются после модерации.
Редактировать чужие статьи нельзя. 

Как обеспечить авторство?
Статью можно пометить как авторское свидетельство. 

Автор может поменять статью, после чего она будет рассказывать про что-то другое.
Значит свидетельство менять после согласования нельзя.

Кто-то может еще раз описать то же самое, только лучше. Такие статьи нужно связывать вместе, как описывающие одно и то же.

Задача - я хочу собрать статьи и хочу чтобы кто-то помог. На этом все.

Статю можно модифицировать, но при этом будет утрачена метка времени - значит приоритет открытия можей уйти. 
Но всегда можно откатить на старый текст и восстановить приоритет.

Статьи можно лайкать, устанаввливая им приоритет при поиске.

Как искать:
1. Поиск по словам в заголовке.
2. Просмотр всех упорядоченных по времени.
3. Через страницу содержания.

Страницы не видны до модерации (выдны в отдельном разделе). 
С правами администратора можно пометить как отмодерированную или написать замечания к ней.

Поиск показывается в виде списка на там же экране. 
Список проматывается и можно выводить далее..

Как возвращаться на главную страницу непонятно. Можно использовать некую иконку в меню.

И того, мы можем сделать верстку:
Панель меню, строка поиска с логином и кнопкой домой, список найденных, компонент для страницы.
Создание статьи в компоненте редактирования, сохранение после редактирования.
Кнопка модерации - можно дописать замечание.

Страницу можно разделить или можно картинку ставить под текстом.

Мотивация - создадим описание автомата.

Можно потом решить вопрос как добавить идексацию гуглом.


Последовательность разработки:
1. Верстка - делим страницу на части с условным контентом.
2. Компоненты - роутинг к компонентам для редактирования и просмотра статей.
3. Модель данных - добавляем в модель стати с атрибутами и историей версий статьи.
4. Отображение статьи по адресу.
5. Отображение найденного по запросу списка статей.
6. Редактирование и сохранение статьи.

Как оформить компоненты?

Запрашивается и показывается статья по Id.
Для показа статьи нужно добавить компонент показа статьи в основной области.

Запрос идет с указанием строки запроса в URL.
Есть вариант пустого запроса и запроса всех.

Компоненты:
Для отображения статьи.
Внутри: постоянный редактор, настроенный для википедии другой вариант - собрать отдельно.
Компонент должен достать параметры из маршрута и запросить то что ему нужно.

Компонент для отображения списка.

Для редактирования и просмотра используем разные компоненты.
Значит нужен маршрут для редактирования. article\id
edit\id

1. Нужна модель данных.
2. Нужны контроллеры для запроста статьи, обновления статьи, удаления, изменения статуса, создания статьи.
3. Нужен компонент, доступный по адресу редактирования, который редактирует или создает новую статью.
4. Нужен компонент, который показывает статью.
5. Контроллер с запросами по словам - возвращает списки статей из базы и переход на них.

Модель:
1. Таблица статей. Статья связана с автором. Статья имеет статус - смодерированная, или нет, черновик.

Сразу сохраняем как черновик, потом отправляем на модерирование.
Смодерированная - это версия.
После модерирования исправлять нельзя.
Можно создать новую статью а старую убрать в архив. Тогда на старую можно добавить ссылку в качестве доказательства своего авторства.
На архивную можно перейти из текущей версии.
Таким образом, связи не нужны.

Статусы:
Черновик -> На модерации -> Отклонена на модерации (то же что черновик) -> На модерации -> Утверждена -> Отправлена в архив.


Привязать автомат:
1. Режим просмотра - только кнопки промотки вперед, назад и ресет к началу. Загружается вместе с текстом.
2. Режим редактирования: функции редактирования, кнопки промотки вперед, назад. Останавливаться на нулевом шаге.

Ставим канвас. Дальше при переходе к статье нужно создать мир и привязать. 



Последовательно по замечаниям.

+1. Мои статьи - фильтр по автору.
+2. Скрывать поле автомата если автомат пустой для страниц содержания.
+3. Поиск по словам.
+4. Добавить ограничение размера статьи и поля.
+5. Кнопки промотки для автомата. Фабрика для разных контроллеров. Четные нечетные шаги при промотке.
+5.1. Возврат к исходному шагу и номер шага.
+6. Масштабирование и скроллинг.
+8. При попытке покинуть адрес - запрос подтверждения на выход из страницы.
7. Отделение админских прав и процесс модерации статьи.
10. Страница содержания - при обновлении базы статья читается из файла json.
Файлы можно экспортировать и импортировать в браузере в режиме администратора. Результат сохраняем в файлах.
11. Получение случайной статьи - контроллер статей.
9. Постраничное чтение в поиске.
14. Настоящая авторизация по почте.
12. Красивая стартовая страница с текстом.
13. Перенести диалоги в компоненты получше с правильной архитектурой передачи данных.
15. Подбирать некрасивые косяки по коду и архитектуре.
16. Верстка под мобильник?

16. Начинаем страницу для гейплея: здесь предлагается начать новый мир, продолжить играть в существующем. Похоже на майнкрафт.
После начала пишет что геймплей еще не готов и показывает пустой канвас с игроком, который может управляться и ставить фигуры.
Дальнейшее - разработка геймлея.

После простейшей страницы 16 можно считать что проект готов.

Кнопки промотки:
На шаг вперед, пуск автоматического, ускорение автоматического.
Стрелочка >| > >> при автоматическом превращается в стоп.
Кнопка возврата в начальное состояние и кнопка изменения направления времени.
Кнопка установки нулевого момента здесь с диалогом подтверждения.
В просмотре - все те же кнопки, кроме установки времени.
Счетчик времени (на канвас).

Палель нужно переиспользовать в режиме песочницы, редактирования и показа статьи.
В игровом режиме будет другая панель.

Для этого можно сделать компонент. 
Компонент будет вызывать методы контроллера управления выполеннием.
Контроллер поддерживает алгоритм выполнения и умеет работать с миром. 
У мира можно сделать интерфейс для управления временем.

Контроллер умеет работать с таймером.
У контроллера есть интерфейс для панели и он ей передается. 
Панель принимает интерфейс и реагирует на него.
Байдинг в данном случае не обязателен. 
Управляющий контроллер будет плоским объектом, значит к нему не нужно биндиться.


Компонент имеет в описании внешние события.
Интегрируя компонент мы пишем какие методы выполнять для событий и как получать состояния для обновления.
Этот код интеграции может быть сложным.

Как реализовывать сложную модель в ангуларе.
Внтури можно запустить сервис, формирующий мир и готовый его моделировать.
Сервис - это модель.
Представление должно обновляться при изменении этой модели.
Представление может просто читать нужные данные из модели при отображении.

Вопрос - ставит ли ангулар переменные под наблюдение.
Допустим, нет и они читаются только по мере перерисовки.
Тогда как-то должны испускаться события, свидетельствующие о необходиомсти перерс

Связываем кнопки, модель и экранную форму.
Для кнопок делаем отдельный компонент.
Компонент выдает события при нажатии кнопок и принимает состояния чтобы показывать информацию на кнопках.

Отдельно нужен контроллер выполнения, который будет оперировать с миром в ответ на события кнопок и обновлять кнопки.

Отдельно нужны компоненты мира, с алгоритмом расчета и связью с канвой.

Представление получает все источники данных, нужные ему для рисования.

Как связывать эти все компоенты?

Компоненты:
1. Представление для рисования. Имеет ссылки на канвас, данные о мире и о координатах.
2. Модель - мир.
3. Модель - окно просмотра.
4. Модель - параметры выполения.
5. Контроллер скроллинга и редактирования. Подписывается на события мыши или клавиатуры для канваса, меняет модели, учитывает модельо выполнения 
   (блокируется).
6. Панель с кнопками для управления. Генерирует события управления. 
7. Контроллер управлеиня - управляет временем выполенния.

CCanvas - компонент с канвасом для рисования криттеров, ищет рисовалку и передает ей канвас,
транслирует события в контроллер управления и редактирования.

Рисовалка - уже есть, имеет ссылку на модель рисования и мир, рисует на указанном канвас.
Перерисовывается получив событие от моделей об изменениях.

Модели- это мир, модель редактирования и модель времени выполения.
Модели сообщают об изменениях.
В модели можно вносить изменения.

Контроллер редактирования: 

Что созадется в корне?
В корневом элементе ставится элемент для канвас.
Элемент тянет за собой рисовалку, которой он должен передать канвас.
Рисовалка тянет за собой нужные ей модели. 
Канвас ищет кому отдавать мыши и создает под себя контроллеры.
Контроллер получает тот же мир что другие.
Компонент управления времем выполнения создает контроллер, который получает модель. 












И того, есть три модели.
Рисовалка использует их всех чтобы выводить картинку.
Два контроллера управляют разными двумя аспектами модели в ответ на события.
События канвас генерируются отдельным регистратором событий и попадают в контроллер.
События кнопок генерируются компонентом кнопок и передаются в контроллер.

Общий принцип сбора сервисов.
Есть корневой компонент, который создает визуальные элементы.
Дальше, визуальные элементы получают нужные им объекты для настройки на них.
Сервисы создаваясь в свою очередь получают компоненты, которые им нужны и собираются на них.

Как быть с моделями и контроллерами?
Допустим, для двух редакторов нужны две разные модели.

Они могут поддерживать одинаковые интерфейсы.

Преимущества от сборки из сервисов - все классы отдельно и не нужна фабрика их собирающая.



Варианты - плоский объект, компонент, сервис.

Компонент - это панель с кнопками.
Представление для рисования можно сделать компонентом, но большого смысла не видно.
Представление должно получить ссылки на все модели.
Контроллеры тоже
Значит не считая панель с кнопками все может быть плоскими объектами.
 
Панель с кнопками генерирует простые события.
События канваса можно напрямую отдавать контроллеру. Тогда контроллер будет уметь работать с канвасом.
Можно менять режимы для тачскрина. Это позволит избежать дополнительного уровня абстракции.

Если все сделать сервисами.
Панель с кнопками получит ссылку на контроллер управления и будет передавать ему события.
Тот же контроллер получит экранная форма.
Контроллер должен получит ссылку на модель с которой он работает.






11. Проверять совпадение паролей.
12. Ресурсы и локализация.
13. Все сценарии работы регистрации с неправильными действиями пользователей.
14. Реальная проверка почты пользователя.

15. Красивая заглавная страница и песочница.
16. Ограничение работы песочницы без авторизации.

На этом этапе можно создавать энциклопедию по автомату.

Следующий этап - геймплей.
Здесь от ангулара остается только несложные элементы интерфейса.
Основная проблема - алгоритмы генерации и редактирования миров, геймлей и прочее.
Опыт - здесь можно поработать над высоконагруженными приложениями, если рассчитывать на многопользовательскую игру.

Вопрос - кто узнает про эту игру.
Просто гуглом найти сложно.


Сбаллансированный геймплей

Первое - нужно формировать рельеф планеты.
Это должна быть форма с островами. Еще желательны пещеры.

Планета имеет форму, на планене есть недоступные области.

Ходим и собираем клетки.
За клетки расширяются возможности.

Клетки на карте могут быть защищены от поглощения.
На такие клетки нельзя наехать полем.
Такие клетки нужно обстреливать своими клетками, чтобы снять защиту.

В оболочке может быть меньше энергии чем нужно для прохода через оболочку. 
Тогда надо разрабатывать стратегию как проходить через оболочку.
Можно стрелять нейтральными клетками, тогда энергии требуется меньше и можно преодолевать большую защиту.

Для конфигураций может сущестовать способ их выгодного разбора, но для этого может требоваться широкое поле и много клеток. 
Или нужно найти способ.

Активная защита - когда система может взрываться при попытке ее разобрать.
Такая защита возможна только при наличии непроницаемых стенок.
Допустим, мы разрешим ставить такие стенки. Тогда будет слишком много возможностей по защите.

Опасные мобы - запрограммировать будет сложно. Могут двигаться, атоковать планерами, собирать ресурсы и таскать их в склады. 
Атоквать все одновременно.
Свои боты - аналогично, но действующие в интересах игрока.

Путешествие через космос. 
В космосе уменьшается весь ресурс.
Поэтому для путешествия нужна большая область.
Кроме того, чем больше расстояние, тем большего размера должна быть конструкция.
Таким образом задача - вывести в космос больше клеток.
При этом, не всегда можно развернуть такой корабль в космосе.
В космосе могут быть метеориты, разрушающие корабль.

И того, игра начинается с необходимости разбирать и поглощать ресурсы, затем строить собственные хранилища ресурсов. 
Хранилища не обязательно защищать для начала.

Возможны простые мобы. Они будут поглощать не защищенные ресурсы. Тогда ресурсы надо минимально огораживать. 
Возможны мобы, которые умеют стрелять планерами и затем пытаться поглотить ресурсы. Такием мобы потребуют более сложной защиты.
Наконец, на планету могут зайти другие игроки и разобрать хранилище.

Собрав достаточно ресурсов можно организовывать переезд на другую планету.
Для этого с собой нужно взять достаточно клеток.

По прибытию клетки будтут полезны в качестве начального запаса энергии, чтобы не начинать все с начала. 
Например, чтобы разобрать хорошо защищенную конструкцию нужна энергия. Если привезти ее с собой, этого может быть достаточно для начала.

Базовый набор планет можно сгенерировать автоматичеси. Они могут быть скучными.

Баланс с чужими планетами:


Получил предельный уровень можно окупировать всю свою ветку вселенной и дальше можно экспериментировать с мобами, наблюдая как они 
развиваются на разных планетах. У мобов может быть интеллект. 
При этом задача статносится другой - построить самые впечатляющие миры со сложными экосистемами, в которых будет увлекательно играть другим.

Схема с параллельными мирами.
Планеты генерируются автоматически, но можно по разному их заселить.

При попадании на планету игрок попадает в свою версию, если он уже там был.
Если не был - в одну из случайно выбранных версий.

Планета на которую однажны попал больше не меняется.
Новая планета может быть выбрана из числа кем-то защищенных.
Если все начинают в одной точке, то защита планет будет похожей.
Т.е. приходиться перемещаться на планету, которую кто-то со сходным уровнем защитил.
Дальше, нужна мотивация для защиты планет.

Если кто-то погиб на планете, считаем что он ограбил ее не успешно.

Мультиплеер - позволяет в реальном времени находиться на планетах одновременно. 

Модели могут оповещать об изменении.
























Защита - могут работать триггеры, которые открывают выход атакующим планерам.

Собранные ресурсы нужно паковать в защищенные хранилища.
Хранилища увеличивают возможности.

Как выбраться в космос?






*/